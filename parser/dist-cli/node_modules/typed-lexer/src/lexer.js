"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const regexp_1 = require("./regexp");
function isString(a) { return typeof (a) === "string"; }
function isBool(a) { return typeof (a) === "boolean"; }
class ResultImplementation {
}
class ResultFactoryImplementation {
    constructor(matchedString) {
        this.matchedString = matchedString;
    }
    tokensWithPos(tokens, nextState) {
        const r = new ResultImplementation();
        r.nextState = nextState;
        r.matchedString = this.matchedString;
        r.tokens = tokens;
        return r;
    }
    tokens(tokens, nextState) {
        if (tokens.length == 0)
            return this.tokensWithPos([], nextState);
        let t2 = tokens.map(t => ({ token: t, startPos: 0, length: 0 }));
        t2[t2.length - 1].length = this.matchedString.length;
        return this.tokensWithPos(t2, nextState);
    }
    tokensWithLen(tokens, nextState) {
        const t2 = tokens;
        let pos = 0;
        for (const t of t2) {
            t.startPos = pos;
            pos += t.length;
        }
        return this.tokensWithPos(t2, nextState);
    }
    token(token, nextState) {
        return this.tokensWithPos([{ token: token, startPos: 0, length: this.matchedString.length }], nextState);
    }
    state(nextState) {
        return this.tokensWithPos([], nextState);
    }
    nothing() {
        return this.tokensWithPos([]);
    }
}
class Rule {
    constructor(handler, statePredicate) {
        this.handler = handler;
        this.statePredicate = statePredicate;
    }
    match(str, pos, state) {
        if (this.statePredicate && !this.statePredicate(state))
            return null;
        let [matchedStr, matchedGroups] = this.internalMatch(str, pos);
        if (matchedStr == null)
            return null;
        const ret = new ResultFactoryImplementation(matchedStr);
        let result = this.handler(matchedStr, ret, state, matchedGroups);
        if (isBool(result)) {
            if (!result)
                return null;
            return ret.tokens([], state);
        }
        else {
            if (result.nextState === undefined)
                result.nextState = state;
            return result;
        }
    }
}
class RegExRule extends Rule {
    constructor(regex, handler, statePredicate) {
        super(handler, statePredicate);
        this.matchRegex = new RegExp(regex, "y");
    }
    internalMatch(str, pos) {
        this.matchRegex.lastIndex = pos;
        let matchedGroups = this.matchRegex.exec(str);
        if (matchedGroups == null || matchedGroups.length == 0)
            return [null, undefined];
        return [matchedGroups[0], matchedGroups];
    }
}
class StringRule extends Rule {
    constructor(matchStr, handler, statePredicate) {
        super(handler, statePredicate);
        this.matchStr = matchStr;
    }
    internalMatch(str, pos) {
        const str2 = str.substr(pos, this.matchStr.length);
        if (str2 !== this.matchStr)
            return [null, undefined];
        return [this.matchStr, undefined];
    }
}
class StaticLexingRules {
    constructor(startState) {
        this.rules = new LexingRules(startState);
    }
    getLexerFor(input, startState) { return this.rules.getLexerFor(input, startState); }
    lex(input, processor) {
        this.rules.lex(input, processor);
        return this;
    }
    lexTokens(input) { return this.rules.lexTokens(input); }
    lexTokensWithStr(input) { return this.rules.lexTokensWithStr(input); }
}
exports.StaticLexingRules = StaticLexingRules;
class LexingRules {
    constructor(startState) {
        this.startState = startState;
        this.rules = [];
    }
    addRule(regex, handler, statePredicate) {
        let rule;
        if (isString(regex))
            rule = new StringRule(regex, handler, statePredicate);
        else if (regex instanceof regexp_1.Matcher)
            rule = new RegExRule(regex.toRegExp(), handler, statePredicate);
        else
            rule = new RegExRule(regex.source, handler, statePredicate);
        this.rules.push(rule);
        return this;
    }
    addDefaultRule(handler, statePredicate) {
        if (handler === undefined)
            handler = (m, ret) => ret.nothing();
        return this.addRule(/[\s\S]/, handler, statePredicate);
    }
    addDefaultSimpleRule(token, statePredicate) {
        return this.addSimpleRule(/[\s\S]/, token, statePredicate);
    }
    addSimpleRule(regex, token, statePredicate, nextState) {
        if (token === undefined) {
            if (nextState === undefined)
                return this.addRule(regex, (m, ret) => ret.nothing(), statePredicate);
            return this.addRule(regex, (m, ret) => ret.state(nextState), statePredicate);
        }
        return this.addRule(regex, (m, ret) => ret.token(token, nextState), statePredicate);
    }
    addSimpleRules(rules, statePredicate, nextState) {
        for (const c in rules)
            this.addSimpleRule(c, rules[c], statePredicate, nextState);
        return this;
    }
    addRuleWithRegexGroups(regex, tokens, statePredicate, nextState) {
        return this.addRule(regex, (m, ret, state, groups) => ret.tokensWithLen(groups.slice(1).map((g, idx) => ({ token: tokens[idx], length: g.length })), nextState), statePredicate);
    }
    getLexerFor(input, startState) {
        startState = startState || this.startState;
        if (startState === undefined)
            throw new Error("No start state is given!");
        return new Lexer(input, this.rules, startState);
    }
    lex(input, processor) {
        const lexer = this.getLexerFor(input);
        while (true) {
            let cur = lexer.next();
            if (cur === undefined)
                break;
            processor(cur, lexer);
        }
        return this;
    }
    lexTokens(input) {
        const result = [];
        this.lex(input, t => result.push(t));
        return result;
    }
    lexTokensWithStr(input) {
        const result = [];
        this.lex(input, (cur, lexer) => {
            const c = lexer.getCur();
            result.push({ token: cur, str: input.substr(c.startPos, c.length) });
        });
        return result;
    }
}
exports.LexingRules = LexingRules;
class LookaheadLexer {
    constructor(lexer) {
        this.lexer = lexer;
    }
    next() {
    }
    pushPosition() { }
    popPosition(handle) { }
    restorePosition(handle) { }
}
class Lexer {
    constructor(input, rules, state) {
        this.input = input;
        this.state = state;
        this.pos = 0;
        this.cur = undefined;
        this.restrained = [];
        this.rules = rules;
    }
    getInput() { return this.input; }
    getCur() { return this.cur; }
    getCurToken() { return this.cur ? this.cur.token : undefined; }
    getCurState() { return this.state; }
    getRestrained() { return this.restrained; }
    next() {
        while (this.restrained.length == 0) {
            if (this.input.length === this.pos) {
                this.cur = undefined;
                return undefined;
            }
            let result = null;
            for (const r of this.rules) {
                result = r.match(this.input, this.pos, this.state);
                if (result != null)
                    break;
            }
            if (result == null)
                throw new Error(`'${this.input.substr(0, 10)}...' could not be matched.`);
            for (const t of result.tokens)
                t.startPos += this.pos; // add offset
            this.pos += result.matchedString.length;
            if (result.nextState)
                this.state = result.nextState;
            this.restrained.push(...result.tokens);
        }
        this.cur = this.restrained.shift();
        return this.cur.token;
    }
}
exports.Lexer = Lexer;
function matches(...elements) { return (other) => elements.some(element => element === other); }
exports.matches = matches;
function matchesNot(...elements) { return (other) => !elements.some(element => element === other); }
exports.matchesNot = matchesNot;
function and(...ops) { return (other) => ops.every(o => o(other)); }
exports.and = and;
function or(...ops) { return (other) => ops.some(o => o(other)); }
exports.or = or;
// from http://stackoverflow.com/questions/728360/most-elegant-way-to-clone-a-javascript-object
function clone(obj) {
    var copy;
    // Handle the 3 simple types, and null or undefined
    if (null == obj || "object" != typeof obj)
        return obj;
    // Handle Date
    if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }
    // Handle Array
    if (obj instanceof Array) {
        copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = clone(obj[i]);
        }
        return copy;
    }
    // Handle Object
    if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr))
                copy[attr] = clone(obj[attr]);
        }
        return copy;
    }
    throw new Error("Unable to copy obj! Its type isn't supported.");
}
exports.clone = clone;
//# sourceMappingURL=lexer.js.map