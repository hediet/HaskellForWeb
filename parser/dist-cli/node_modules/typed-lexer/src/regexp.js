"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Matcher {
    concat(m) {
        return concat(this, m);
    }
}
exports.Matcher = Matcher;
function asMatcher(m) {
    if (typeof m === "string")
        return new StringMatcher(m);
    return m;
}
exports.asMatcher = asMatcher;
function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
class StringMatcher extends Matcher {
    constructor(literal) {
        super();
        this.literal = literal;
    }
    toRegExp() { return escapeRegExp(this.literal); }
}
function range(startChar, endChar) {
    return new RangeMatcher(startChar, endChar);
}
exports.range = range;
class RangeMatcher extends Matcher {
    constructor(startChar, endChar) {
        super();
        this.startChar = startChar;
        this.endChar = endChar;
    }
    toRegExp() {
        return `[${this.startChar}-${this.endChar}]`;
    }
}
class AnyMatcher extends Matcher {
    toRegExp() { return "."; }
}
exports.any = new AnyMatcher();
function noneOfChars(items) {
    return new NegativeCharacterClassMatcher(items);
}
exports.noneOfChars = noneOfChars;
class NegativeCharacterClassMatcher extends Matcher {
    constructor(items) {
        super();
        this.items = items;
    }
    toRegExp() { return `[^${escapeRegExp(this.items.join(""))}]`; }
}
function oneOf(...items) {
    if (items.length === 0)
        throw new Error("No choice given.");
    let m = asMatcher(items[0]);
    for (let i = 1; i < items.length; i++)
        m = new ChoiceMatcher(m, asMatcher(items[i]));
    return m;
}
exports.oneOf = oneOf;
class ChoiceMatcher extends Matcher {
    constructor(first, second) {
        super();
        this.first = first;
        this.second = second;
    }
    toRegExp() {
        return `(?:${this.first.toRegExp()})|(?:${this.second.toRegExp()})`;
    }
}
function concat(...items) {
    if (items.length === 0)
        throw new Error("No matcher given.");
    let m = asMatcher(items[0]);
    for (let i = 1; i < items.length; i++)
        m = new ConcatMatcher(m, asMatcher(items[i]));
    return m;
}
exports.concat = concat;
class ConcatMatcher extends Matcher {
    constructor(first, second) {
        super();
        this.first = first;
        this.second = second;
    }
    toRegExp() {
        return `(${this.first.toRegExp()})(${this.second.toRegExp()})`;
    }
}
function repeat0(m) {
    return new RepeatMatcher(asMatcher(m), 0, undefined);
}
exports.repeat0 = repeat0;
function repeat1(m) {
    return new RepeatMatcher(asMatcher(m), 1, undefined);
}
exports.repeat1 = repeat1;
function optional(m) {
    return new RepeatMatcher(asMatcher(m), 0, 1);
}
exports.optional = optional;
class RepeatMatcher extends Matcher {
    constructor(m, min, max) {
        super();
        this.m = m;
        this.min = min;
        this.max = max;
    }
    toRegExp() {
        let op;
        if (this.min === 0 && this.max === undefined)
            op = "*";
        else if (this.min === 1 && this.max === undefined)
            op = "+";
        else if (this.min === 0 && this.max === 1)
            op = "?";
        else if (this.max !== undefined)
            op = `{${this.min}, ${this.max}}`;
        else
            op = `{${this.min},}`;
        return `(?:${this.m.toRegExp()})${op}`;
    }
}
//# sourceMappingURL=regexp.js.map